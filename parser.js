function parseRLE(input) {
    let result = [];
    let lines = input.split('\n');
    let x = 0;
    let y = 0;
    let headerParsed = false;

    for (let line of lines) {
        line = line.trim();
        if (line.startsWith('#') || line === '') {
            continue; // Skip comments and empty lines
        }
        if (!headerParsed) {
            if (line.startsWith('x')) {
                headerParsed = true;
            }
            continue; // Skip header line
        }
    
        let countStr = '';
        for (let char of line) {
            if (char >= '0' && char <= '9') {
                countStr += char;
            } else if (char === 'b') {
                let count = countStr === '' ? 1 : parseInt(countStr);
                x += count; // Dead cells, just move x
                countStr = '';
            } else if (char === 'o') {
                let count = countStr === '' ? 1 : parseInt(countStr);
                for (let i = 0; i < count; i++) {
                    result.push({x: x, y: y});
                    x++;
                }
                countStr = '';
            } else if (char === '$') {
                let count = countStr === '' ? 1 : parseInt(countStr);
                y += count;
                x = 0; // Reset x to the beginning of the new line
                countStr = '';
            } else if (char === '!') {
                break; // End of pattern
            }
        }
    }
    return result;
}

function loadFromParsed(aliveCellsMap, parsedCells) {
    aliveCellsMap.clear();
    
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    for (let cell of parsedCells) {

        let cellHash = getHash(cell.x, cell.y);
        aliveCellsMap.set(cellHash, {x: cell.x, y: cell.y, age: 0});

        if (cell.x > maxX) maxX = cell.x;
        if (cell.x < minX) minX = cell.x;
        if (cell.y > maxY) maxY = cell.y;
        if (cell.y < minY) minY = cell.y;
    }

    centerCameraOnPattern(minX, maxX, minY, maxY);
}

function centerCameraOnPattern(minX, maxX, minY, maxY) {
    const patternCenterX = (minX + maxX) / 2;
    const patternCenterY = (minY + maxY) / 2;

    camera.x = patternCenterX - (width / 2); 
    camera.y = patternCenterY - (height / 2);
}

function saveStateAsRLE(aliveCellsMap) {
    // Step 1: Find bounds
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    for (let cell of aliveCellsMap.values()) {
        if (cell.x > maxX) maxX = cell.x;
        if (cell.x < minX) minX = cell.x;
        if (cell.y > maxY) maxY = cell.y;
        if (cell.y < minY) minY = cell.y;
    }

    // Step 2: Write headers
    let rle = '#C RLE Generated by ConwayLightSim (simulator made by Eric Garcia - github.com/nairec)\n';
    let width = maxX - minX + 1;
    let height = maxY - minY + 1;
    rle += `x = ${width}, y = ${height}, rule = B3/S23\n`;

    // Step 3: Write body
    for (let y = minY; y <= maxY; y++) {
        let runCount = 0;
        let lastState = 'b'; // Start with dead cells
        for (let x = minX; x <= maxX; x++) {
            let cellHash = getHash(x, y);
            let isAlive = aliveCellsMap.has(cellHash);
            let currentState = isAlive ? 'o' : 'b';

            if (currentState === lastState) {
                runCount++;
            } else {
                if (runCount > 0) {
                    rle += (runCount > 1 ? runCount : '') + lastState;
                }
                lastState = currentState;
                runCount = 1;
            }
        }
        // Write the last run in the row
        if (runCount > 0) {
            rle += (runCount > 1 ? runCount : '') + lastState;
        }
        rle += '$\n'; // End of line
    }

    return rle + '!';
}